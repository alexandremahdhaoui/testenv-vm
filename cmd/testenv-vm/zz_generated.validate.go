// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:e8e65b978f3adf1047d951d64b98305815757949ce530bdaa4081b845a2500c1

package main

import (
	"fmt"

	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
	v1 "github.com/alexandremahdhaoui/testenv-vm/api/v1"
)

// ValidateBootSpec validates a BootSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateBootSpec(s *v1.BootSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: order
	if len(s.Order) == 0 {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.order",
			Message: "required field is missing or empty",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateCloudInitNameservers validates a CloudInitNameservers and returns validation results.
// It checks required fields and validates enum values.
func ValidateCloudInitNameservers(s *v1.CloudInitNameservers) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateCloudInitReadinessSpec validates a CloudInitReadinessSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateCloudInitReadinessSpec(s *v1.CloudInitReadinessSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateUserSpec validates a UserSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateUserSpec(s *v1.UserSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateWriteFileSpec validates a WriteFileSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateWriteFileSpec(s *v1.WriteFileSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: content
	if s.Content == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.content",
			Message: "required field is missing",
		})
	}
	// Validate required field: path
	if s.Path == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.path",
			Message: "required field is missing",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateDHCPSpec validates a DHCPSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateDHCPSpec(s *v1.DHCPSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateDNSSpec validates a DNSSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateDNSSpec(s *v1.DNSSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateDiskSpec validates a DiskSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateDiskSpec(s *v1.DiskSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: size
	if s.Size == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.size",
			Message: "required field is missing",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateImageSpec validates a ImageSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateImageSpec(s *v1.ImageSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: source
	if s.Source == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.source",
			Message: "required field is missing",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateKeySpec validates a KeySpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateKeySpec(s *v1.KeySpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: type
	if s.Type == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.type",
			Message: "required field is missing",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateTFTPSpec validates a TFTPSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateTFTPSpec(s *v1.TFTPSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateProviderConfig validates a ProviderConfig and returns validation results.
// It checks required fields and validates enum values.
func ValidateProviderConfig(s *v1.ProviderConfig) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: engine
	if s.Engine == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.engine",
			Message: "required field is missing",
		})
	}
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateSSHReadinessSpec validates a SSHReadinessSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateSSHReadinessSpec(s *v1.SSHReadinessSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateTCPReadinessSpec validates a TCPReadinessSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateTCPReadinessSpec(s *v1.TCPReadinessSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateResourceRef validates a ResourceRef and returns validation results.
// It checks required fields and validates enum values.
func ValidateResourceRef(s *v1.ResourceRef) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: kind
	if s.Kind == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.kind",
			Message: "required field is missing",
		})
	}
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateCloudInitEthernetConfig validates a CloudInitEthernetConfig and returns validation results.
// It checks required fields and validates enum values.
func ValidateCloudInitEthernetConfig(s *v1.CloudInitEthernetConfig) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}
	// Validate nested reference: nameservers
	{
		nested := s.Nameservers
		nestedResult := ValidateCloudInitNameservers(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.nameservers." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateImageResource validates a ImageResource and returns validation results.
// It checks required fields and validates enum values.
func ValidateImageResource(s *v1.ImageResource) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}
	// Validate required reference field: spec
	// Validate nested reference: spec
	{
		nested := s.Spec
		nestedResult := ValidateImageSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.spec." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateKeyResource validates a KeyResource and returns validation results.
// It checks required fields and validates enum values.
func ValidateKeyResource(s *v1.KeyResource) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}
	// Validate required reference field: spec
	// Validate nested reference: spec
	{
		nested := s.Spec
		nestedResult := ValidateKeySpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.spec." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateNetworkSpec validates a NetworkSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateNetworkSpec(s *v1.NetworkSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate nested reference: dhcp
	if s.Dhcp != nil {
		nestedResult := ValidateDHCPSpec(s.Dhcp)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.dhcp." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate nested reference: dns
	if s.Dns != nil {
		nestedResult := ValidateDNSSpec(s.Dns)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.dns." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate nested reference: tftp
	if s.Tftp != nil {
		nestedResult := ValidateTFTPSpec(s.Tftp)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.tftp." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateReadinessSpec validates a ReadinessSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateReadinessSpec(s *v1.ReadinessSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate nested reference: cloudInit
	{
		nested := s.CloudInit
		nestedResult := ValidateCloudInitReadinessSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.cloudInit." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate nested reference: ssh
	{
		nested := s.Ssh
		nestedResult := ValidateSSHReadinessSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.ssh." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate nested reference: tcp
	{
		nested := s.Tcp
		nestedResult := ValidateTCPReadinessSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.tcp." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateCloudInitNetworkConfig validates a CloudInitNetworkConfig and returns validation results.
// It checks required fields and validates enum values.
func ValidateCloudInitNetworkConfig(s *v1.CloudInitNetworkConfig) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate array of references: ethernets
	for i, item := range s.Ethernets {
		nestedResult := ValidateCloudInitEthernetConfig(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.ethernets[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateNetworkResource validates a NetworkResource and returns validation results.
// It checks required fields and validates enum values.
func ValidateNetworkResource(s *v1.NetworkResource) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: kind
	if s.Kind == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.kind",
			Message: "required field is missing",
		})
	}
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}
	// Validate required reference field: spec
	// Validate nested reference: spec
	{
		nested := s.Spec
		nestedResult := ValidateNetworkSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.spec." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateCloudInitSpec validates a CloudInitSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateCloudInitSpec(s *v1.CloudInitSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate nested reference: networkConfig
	{
		nested := s.NetworkConfig
		nestedResult := ValidateCloudInitNetworkConfig(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.networkConfig." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate array of references: users
	for i, item := range s.Users {
		nestedResult := ValidateUserSpec(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.users[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}
	// Validate array of references: writeFiles
	for i, item := range s.WriteFiles {
		nestedResult := ValidateWriteFileSpec(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.writeFiles[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateVMSpec validates a VMSpec and returns validation results.
// It checks required fields and validates enum values.
func ValidateVMSpec(s *v1.VMSpec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required reference field: boot
	// Validate nested reference: boot
	{
		nested := s.Boot
		nestedResult := ValidateBootSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.boot." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate nested reference: cloudInit
	{
		nested := s.CloudInit
		nestedResult := ValidateCloudInitSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.cloudInit." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate required reference field: disk
	// Validate nested reference: disk
	{
		nested := s.Disk
		nestedResult := ValidateDiskSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.disk." + e.Field,
					Message: e.Message,
				})
			}
		}
	}
	// Validate required field: network
	if s.Network == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.network",
			Message: "required field is missing",
		})
	}
	// Validate nested reference: readiness
	{
		nested := s.Readiness
		nestedResult := ValidateReadinessSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.readiness." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateVMResource validates a VMResource and returns validation results.
// It checks required fields and validates enum values.
func ValidateVMResource(s *v1.VMResource) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate required field: name
	if s.Name == "" {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.name",
			Message: "required field is missing",
		})
	}
	// Validate required reference field: spec
	// Validate nested reference: spec
	{
		nested := s.Spec
		nestedResult := ValidateVMSpec(&nested)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   "spec.spec." + e.Field,
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// ValidateSpec validates a Spec and returns validation results.
// It checks required fields and validates enum values.
func ValidateSpec(s *v1.Spec) *mcptypes.ConfigValidateOutput {
	if s == nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: true,
		}
	}

	var errors []mcptypes.ValidationError
	// Validate array of references: images
	for i, item := range s.Images {
		nestedResult := ValidateImageResource(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.images[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}
	// Validate array of references: keys
	for i, item := range s.Keys {
		nestedResult := ValidateKeyResource(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.keys[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}
	// Validate array of references: networks
	for i, item := range s.Networks {
		nestedResult := ValidateNetworkResource(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.networks[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}
	// Validate required array of references: providers
	if len(s.Providers) == 0 {
		errors = append(errors, mcptypes.ValidationError{
			Field:   "spec.providers",
			Message: "required field is missing or empty",
		})
	}
	// Validate array of references: providers
	for i, item := range s.Providers {
		nestedResult := ValidateProviderConfig(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.providers[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}
	// Validate array of references: vms
	for i, item := range s.Vms {
		nestedResult := ValidateVMResource(&item)
		if !nestedResult.Valid {
			for _, e := range nestedResult.Errors {
				errors = append(errors, mcptypes.ValidationError{
					Field:   fmt.Sprintf("spec.vms[%d].%s", i, e.Field),
					Message: e.Message,
				})
			}
		}
	}

	if len(errors) > 0 {
		return &mcptypes.ConfigValidateOutput{
			Valid:  false,
			Errors: errors,
		}
	}

	return &mcptypes.ConfigValidateOutput{
		Valid: true,
	}
}

// Validate validates a Spec and returns validation results.
// This is the main entry point for validation.
func Validate(s *v1.Spec) *mcptypes.ConfigValidateOutput {
	return ValidateSpec(s)
}

// ValidateMap validates a map[string]interface{} by first parsing it to a Spec.
// This is a convenience function for validating spec data from forge.yaml.
func ValidateMap(m map[string]interface{}) *mcptypes.ConfigValidateOutput {
	s, err := v1.FromMap(m)
	if err != nil {
		return &mcptypes.ConfigValidateOutput{
			Valid: false,
			Errors: []mcptypes.ValidationError{
				{
					Field:   "spec",
					Message: err.Error(),
				},
			},
		}
	}

	return Validate(s)
}

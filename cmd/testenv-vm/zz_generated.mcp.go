// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:fdb998b20f1ee9ea9722159752829cc1a291a9a15dd04d0a9dfc3b82e83cc788

package main

import (
	"context"
	"fmt"

	"github.com/alexandremahdhaoui/forge/pkg/engineframework"
	"github.com/alexandremahdhaoui/forge/pkg/mcpserver"
	"github.com/alexandremahdhaoui/forge/pkg/mcptypes"
	"github.com/alexandremahdhaoui/forge/pkg/mcputil"
	v1 "github.com/alexandremahdhaoui/testenv-vm/api/v1"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// CreateFunc is the signature for the create operation with typed Spec.
// This is the function that engine authors implement.
type CreateFunc func(ctx context.Context, input engineframework.CreateInput, s *v1.Spec) (*engineframework.TestEnvArtifact, error)

// DeleteFunc is the signature for the delete operation with typed Spec.
// This is the function that engine authors implement.
// Note: Spec may be nil for delete operations if metadata is sufficient.
type DeleteFunc func(ctx context.Context, input engineframework.DeleteInput, s *v1.Spec) error

// SetupMCPServer creates and configures the MCP server with all required tools.
// It registers create, delete, and config-validate tools.
func SetupMCPServer(name string, version string, createFn CreateFunc, deleteFn DeleteFunc) (*mcpserver.Server, error) {
	server := mcpserver.New(name, version)

	config := engineframework.TestEnvSubengineConfig{
		Name:       name,
		Version:    version,
		CreateFunc: wrapCreateFunc(createFn),
		DeleteFunc: wrapDeleteFunc(deleteFn),
	}

	if err := engineframework.RegisterTestEnvSubengineTools(server, config); err != nil {
		return nil, fmt.Errorf("failed to register testenv subengine tools: %w", err)
	}

	// Register config-validate tool
	mcpserver.RegisterTool(server, &mcp.Tool{
		Name:        "config-validate",
		Description: fmt.Sprintf("Validate %s configuration", name),
	}, handleConfigValidate)

	return server, nil
}

// wrapCreateFunc wraps a typed CreateFunc into an engineframework.CreateFunc.
// It handles parsing and validation of the Spec from the input.
func wrapCreateFunc(fn CreateFunc) engineframework.CreateFunc {
	return func(ctx context.Context, input engineframework.CreateInput) (*engineframework.TestEnvArtifact, error) {
		// Parse Spec from input
		// CreateInput.Spec is map[string]any (same as map[string]interface{})
		spec, err := v1.FromMap(input.Spec)
		if err != nil {
			return nil, fmt.Errorf("failed to parse spec: %w", err)
		}

		// Validate Spec
		output := Validate(spec)
		if !output.Valid {
			if len(output.Errors) > 0 {
				return nil, fmt.Errorf("validation failed: %s", output.Errors[0].Message)
			}
			return nil, fmt.Errorf("validation failed")
		}

		// Call the typed create function
		return fn(ctx, input, spec)
	}
}

// wrapDeleteFunc wraps a typed DeleteFunc into an engineframework.DeleteFunc.
// It handles parsing the Spec from metadata if available.
// Note: For delete operations, the Spec may be nil if the engine only needs
// metadata to perform cleanup.
func wrapDeleteFunc(fn DeleteFunc) engineframework.DeleteFunc {
	return func(ctx context.Context, input engineframework.DeleteInput) error {
		// For delete operations, Spec is not typically available in DeleteInput.
		// The engine should use Metadata to get any information it needs.
		// We pass nil Spec to the typed function.
		// If an engine needs Spec during delete, it should store relevant data
		// in Metadata during create.
		var spec *v1.Spec

		// Call the typed delete function with nil spec
		return fn(ctx, input, spec)
	}
}

// handleConfigValidate handles the config-validate MCP tool.
func handleConfigValidate(
	_ context.Context,
	_ *mcp.CallToolRequest,
	input mcptypes.ConfigValidateInput,
) (*mcp.CallToolResult, any, error) {
	output := ValidateMap(input.Spec)

	if output.Valid {
		result, artifact := mcputil.SuccessResultWithArtifact(
			"Configuration is valid",
			output,
		)
		return result, artifact, nil
	}

	result, artifact := mcputil.SuccessResultWithArtifact(
		fmt.Sprintf("Configuration validation failed with %d error(s)", len(output.Errors)),
		output,
	)
	return result, artifact, nil
}

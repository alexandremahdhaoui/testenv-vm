// Code generated by forge-dev. DO NOT EDIT.
// Source: spec.openapi.yaml
// SourceChecksum: sha256:d77adff167f6c9f7c497e949bb7d2d1553f7fcd6d3ea7347c1d782f0d968e833

package v1

import (
	"fmt"
)

// BootSpec represents the BootSpec configuration.
// Boot options configuration.
type BootSpec struct {
	// Firmware type: bios or uefi.
	Firmware string `json:"firmware,omitempty"`
	// Boot device order: network, hd, cdrom.
	Order []string `json:"order"`
}

// CloudInitNameservers represents the CloudInitNameservers configuration.
// DNS server configuration.
type CloudInitNameservers struct {
	// DNS server IP addresses.
	Addresses []string `json:"addresses,omitempty"`
}

// UserSpec represents the UserSpec configuration.
// User to create via cloud-init.
type UserSpec struct {
	// Username.
	Name string `json:"name"`
	// Public keys to add to authorized_keys.
	SshAuthorizedKeys []string `json:"sshAuthorizedKeys,omitempty"`
	// Sudo rules (e.g., ALL=(ALL) NOPASSWD:ALL).
	Sudo string `json:"sudo,omitempty"`
}

// WriteFileSpec represents the WriteFileSpec configuration.
// File to write via cloud-init.
type WriteFileSpec struct {
	// File content.
	Content string `json:"content"`
	// File path.
	Path string `json:"path"`
	// File permissions (e.g., 0644).
	Permissions string `json:"permissions,omitempty"`
}

// DHCPSpec represents the DHCPSpec configuration.
// DHCP server configuration.
type DHCPSpec struct {
	// Enables DHCP.
	Enabled bool `json:"enabled"`
	// Lease time duration (e.g., 12h).
	LeaseTime string `json:"leaseTime,omitempty"`
	// Last IP in DHCP range.
	RangeEnd string `json:"rangeEnd"`
	// First IP in DHCP range.
	RangeStart string `json:"rangeStart"`
}

// DNSSpec represents the DNSSpec configuration.
// DNS forwarding configuration.
type DNSSpec struct {
	// Enables DNS forwarding.
	Enabled bool `json:"enabled,omitempty"`
	// DNS servers to forward to.
	Servers []string `json:"servers,omitempty"`
}

// DiskSpec represents the DiskSpec configuration.
// VM disk configuration.
type DiskSpec struct {
	// Path/URL to base image (QCOW2, AMI, etc.).
	BaseImage string `json:"baseImage,omitempty"`
	// Disk size (e.g., 20G).
	Size string `json:"size"`
}

// ImageSpec represents the ImageSpec configuration.
// Image-specific configuration.
type ImageSpec struct {
	// Optional alternative name for template references.
	Alias string `json:"alias,omitempty"`
	// Expected SHA256 checksum of the image file.
	Sha256 string `json:"sha256,omitempty"`
	// Image source - either a well-known reference or an HTTPS URL.
	Source string `json:"source"`
}

// KeySpec represents the KeySpec configuration.
// Key-specific configuration.
type KeySpec struct {
	// Key size in bits.
	Bits int `json:"bits,omitempty"`
	// Optional comment for the public key.
	Comment string `json:"comment,omitempty"`
	// Directory to write key files to.
	OutputDir string `json:"outputDir,omitempty"`
	// Key type: rsa, ed25519, ecdsa.
	Type string `json:"type"`
}

// TFTPSpec represents the TFTPSpec configuration.
// TFTP server configuration for PXE boot.
type TFTPSpec struct {
	// Default boot file (e.g., undionly.kpxe).
	BootFile string `json:"bootFile"`
	// Enables TFTP server.
	Enabled bool `json:"enabled"`
	// Directory for TFTP files.
	Root string `json:"root"`
}

// ProviderConfig represents the ProviderConfig configuration.
// Provider configuration. Providers are MCP servers that implement resource provisioning.
type ProviderConfig struct {
	// Marks this provider as the default for resources without explicit provider.
	Default bool `json:"default,omitempty"`
	// Path to the provider binary or Go package.
	Engine string `json:"engine"`
	// Unique identifier for this provider.
	Name string `json:"name"`
	// Provider-specific configuration passed during initialization.
	Spec map[string]interface{} `json:"spec,omitempty"`
}

// SSHReadinessSpec represents the SSHReadinessSpec configuration.
// SSH readiness check configuration.
type SSHReadinessSpec struct {
	// Enables SSH readiness check.
	Enabled bool `json:"enabled"`
	// Private key path (can use template).
	PrivateKey string `json:"privateKey,omitempty"`
	// Timeout for SSH to become available (e.g., 5m).
	Timeout string `json:"timeout"`
	// User for SSH connection.
	User string `json:"user,omitempty"`
}

// ResourceRef represents the ResourceRef configuration.
// Uniquely identifies a resource.
type ResourceRef struct {
	// Resource type: vm, network, key.
	Kind string `json:"kind"`
	// User-defined identifier.
	Name string `json:"name"`
	// Provider that manages this resource.
	Provider string `json:"provider,omitempty"`
}

// CloudInitEthernetConfig represents the CloudInitEthernetConfig configuration.
// Single ethernet interface configuration.
type CloudInitEthernetConfig struct {
	// Static IP addresses in CIDR notation.
	Addresses []string `json:"addresses,omitempty"`
	// Enables DHCP for IPv4. Defaults to false if addresses is set.
	Dhcp4 bool `json:"dhcp4,omitempty"`
	// IPv4 gateway address.
	Gateway4 string `json:"gateway4,omitempty"`
	// Interface name pattern (e.g., ens2, en*, eth*).
	Name        string               `json:"name"`
	Nameservers CloudInitNameservers `json:"nameservers,omitempty"`
}

// ImageResource represents the ImageResource configuration.
// VM base image resource.
type ImageResource struct {
	// Unique identifier for this image.
	Name string    `json:"name"`
	Spec ImageSpec `json:"spec"`
}

// KeyResource represents the KeyResource configuration.
// SSH key resource.
type KeyResource struct {
	// Unique identifier for this key.
	Name string `json:"name"`
	// Name of the provider to use. If empty, uses default provider.
	Provider string `json:"provider,omitempty"`
	// Provider-specific configuration.
	ProviderSpec map[string]interface{} `json:"providerSpec,omitempty"`
	Spec         KeySpec                `json:"spec"`
}

// NetworkSpec represents the NetworkSpec configuration.
// Network-specific configuration.
type NetworkSpec struct {
	// References another network resource (for layered networks).
	AttachTo string `json:"attachTo,omitempty"`
	// Network CIDR (e.g., 192.168.100.1/24).
	Cidr string   `json:"cidr,omitempty"`
	Dhcp DHCPSpec `json:"dhcp,omitempty"`
	Dns  DNSSpec  `json:"dns,omitempty"`
	// Gateway IP address.
	Gateway string `json:"gateway,omitempty"`
	// Maximum transmission unit size.
	Mtu  int      `json:"mtu,omitempty"`
	Tftp TFTPSpec `json:"tftp,omitempty"`
}

// ReadinessSpec represents the ReadinessSpec configuration.
// Readiness checks configuration.
type ReadinessSpec struct {
	Ssh SSHReadinessSpec `json:"ssh,omitempty"`
}

// CloudInitNetworkConfig represents the CloudInitNetworkConfig configuration.
// Cloud-init network settings using netplan version 2 format.
type CloudInitNetworkConfig struct {
	// Ethernet interface configurations.
	Ethernets []CloudInitEthernetConfig `json:"ethernets,omitempty"`
}

// NetworkResource represents the NetworkResource configuration.
// Network resource.
type NetworkResource struct {
	// Network type: bridge, libvirt, dnsmasq, vpc, subnet, security-group.
	Kind string `json:"kind"`
	// Unique identifier for this network.
	Name string `json:"name"`
	// Name of the provider to use. If empty, uses default provider.
	Provider string `json:"provider,omitempty"`
	// Provider-specific configuration.
	ProviderSpec map[string]interface{} `json:"providerSpec,omitempty"`
	Spec         NetworkSpec            `json:"spec"`
}

// CloudInitSpec represents the CloudInitSpec configuration.
// Cloud-init configuration.
type CloudInitSpec struct {
	// Hostname for the VM.
	Hostname      string                 `json:"hostname,omitempty"`
	NetworkConfig CloudInitNetworkConfig `json:"networkConfig,omitempty"`
	// Packages to install.
	Packages []string `json:"packages,omitempty"`
	// Commands to run.
	Runcmd []string `json:"runcmd,omitempty"`
	// Users to create.
	Users []UserSpec `json:"users,omitempty"`
	// Files to write.
	WriteFiles []WriteFileSpec `json:"writeFiles,omitempty"`
}

// VMSpec represents the VMSpec configuration.
// VM-specific configuration.
type VMSpec struct {
	Boot      BootSpec      `json:"boot"`
	CloudInit CloudInitSpec `json:"cloudInit,omitempty"`
	Disk      DiskSpec      `json:"disk"`
	// Memory in MB.
	Memory int `json:"memory"`
	// Name of the network resource to attach.
	Network   string        `json:"network"`
	Readiness ReadinessSpec `json:"readiness,omitempty"`
	// Number of virtual CPUs.
	Vcpus int `json:"vcpus"`
}

// VMResource represents the VMResource configuration.
// VM resource.
type VMResource struct {
	// Unique identifier for this VM.
	Name string `json:"name"`
	// Name of the provider to use. If empty, uses default provider.
	Provider string `json:"provider,omitempty"`
	// Provider-specific configuration.
	ProviderSpec map[string]interface{} `json:"providerSpec,omitempty"`
	Spec         VMSpec                 `json:"spec"`
}

// Spec represents the Spec configuration.
// Top-level specification for a test environment.
type Spec struct {
	// Directory for storing artifacts (keys, logs, etc.).
	ArtifactDir string `json:"artifactDir,omitempty"`
	// Whether to clean up resources on failure. Defaults to true.
	CleanupOnFailure bool `json:"cleanupOnFailure,omitempty"`
	// Default base image to use for VMs. Can be a well-known reference or HTTPS URL.
	DefaultBaseImage string `json:"defaultBaseImage,omitempty"`
	// Name of the default provider to use when not specified.
	DefaultProvider string `json:"defaultProvider,omitempty"`
	// Directory for caching downloaded VM base images.
	ImageCacheDir string `json:"imageCacheDir,omitempty"`
	// VM base images to download and cache.
	Images []ImageResource `json:"images,omitempty"`
	// SSH key pair resources to create.
	Keys []KeyResource `json:"keys,omitempty"`
	// Network infrastructure resources to create.
	Networks []NetworkResource `json:"networks,omitempty"`
	// Available providers for resource provisioning.
	Providers []ProviderConfig `json:"providers"`
	// Directory for persisting environment state.
	StateDir string `json:"stateDir,omitempty"`
	// Virtual machine resources to create.
	Vms []VMResource `json:"vms,omitempty"`
}

// BootSpecFromMap creates a BootSpec from a map[string]interface{}.
func BootSpecFromMap(m map[string]interface{}) (*BootSpec, error) {
	if m == nil {
		return &BootSpec{}, nil
	}

	s := &BootSpec{}
	// Parse firmware
	if v, ok := m["firmware"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Firmware = val
		} else {
			return nil, fmt.Errorf("field firmware: expected string, got %T", v)
		}
	}
	// Parse order
	if v, ok := m["order"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Order = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Order = append(s.Order, str)
				} else {
					return nil, fmt.Errorf("field order[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Order = arr
		} else {
			return nil, fmt.Errorf("field order: expected []string, got %T", v)
		}
	}
	return s, nil
}

// CloudInitNameserversFromMap creates a CloudInitNameservers from a map[string]interface{}.
func CloudInitNameserversFromMap(m map[string]interface{}) (*CloudInitNameservers, error) {
	if m == nil {
		return &CloudInitNameservers{}, nil
	}

	s := &CloudInitNameservers{}
	// Parse addresses
	if v, ok := m["addresses"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Addresses = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Addresses = append(s.Addresses, str)
				} else {
					return nil, fmt.Errorf("field addresses[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Addresses = arr
		} else {
			return nil, fmt.Errorf("field addresses: expected []string, got %T", v)
		}
	}
	return s, nil
}

// UserSpecFromMap creates a UserSpec from a map[string]interface{}.
func UserSpecFromMap(m map[string]interface{}) (*UserSpec, error) {
	if m == nil {
		return &UserSpec{}, nil
	}

	s := &UserSpec{}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse sshAuthorizedKeys
	if v, ok := m["sshAuthorizedKeys"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.SshAuthorizedKeys = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.SshAuthorizedKeys = append(s.SshAuthorizedKeys, str)
				} else {
					return nil, fmt.Errorf("field sshAuthorizedKeys[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.SshAuthorizedKeys = arr
		} else {
			return nil, fmt.Errorf("field sshAuthorizedKeys: expected []string, got %T", v)
		}
	}
	// Parse sudo
	if v, ok := m["sudo"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Sudo = val
		} else {
			return nil, fmt.Errorf("field sudo: expected string, got %T", v)
		}
	}
	return s, nil
}

// WriteFileSpecFromMap creates a WriteFileSpec from a map[string]interface{}.
func WriteFileSpecFromMap(m map[string]interface{}) (*WriteFileSpec, error) {
	if m == nil {
		return &WriteFileSpec{}, nil
	}

	s := &WriteFileSpec{}
	// Parse content
	if v, ok := m["content"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Content = val
		} else {
			return nil, fmt.Errorf("field content: expected string, got %T", v)
		}
	}
	// Parse path
	if v, ok := m["path"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Path = val
		} else {
			return nil, fmt.Errorf("field path: expected string, got %T", v)
		}
	}
	// Parse permissions
	if v, ok := m["permissions"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Permissions = val
		} else {
			return nil, fmt.Errorf("field permissions: expected string, got %T", v)
		}
	}
	return s, nil
}

// DHCPSpecFromMap creates a DHCPSpec from a map[string]interface{}.
func DHCPSpecFromMap(m map[string]interface{}) (*DHCPSpec, error) {
	if m == nil {
		return &DHCPSpec{}, nil
	}

	s := &DHCPSpec{}
	// Parse enabled
	if v, ok := m["enabled"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Enabled = val
		} else {
			return nil, fmt.Errorf("field enabled: expected bool, got %T", v)
		}
	}
	// Parse leaseTime
	if v, ok := m["leaseTime"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.LeaseTime = val
		} else {
			return nil, fmt.Errorf("field leaseTime: expected string, got %T", v)
		}
	}
	// Parse rangeEnd
	if v, ok := m["rangeEnd"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.RangeEnd = val
		} else {
			return nil, fmt.Errorf("field rangeEnd: expected string, got %T", v)
		}
	}
	// Parse rangeStart
	if v, ok := m["rangeStart"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.RangeStart = val
		} else {
			return nil, fmt.Errorf("field rangeStart: expected string, got %T", v)
		}
	}
	return s, nil
}

// DNSSpecFromMap creates a DNSSpec from a map[string]interface{}.
func DNSSpecFromMap(m map[string]interface{}) (*DNSSpec, error) {
	if m == nil {
		return &DNSSpec{}, nil
	}

	s := &DNSSpec{}
	// Parse enabled
	if v, ok := m["enabled"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Enabled = val
		} else {
			return nil, fmt.Errorf("field enabled: expected bool, got %T", v)
		}
	}
	// Parse servers
	if v, ok := m["servers"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Servers = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Servers = append(s.Servers, str)
				} else {
					return nil, fmt.Errorf("field servers[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Servers = arr
		} else {
			return nil, fmt.Errorf("field servers: expected []string, got %T", v)
		}
	}
	return s, nil
}

// DiskSpecFromMap creates a DiskSpec from a map[string]interface{}.
func DiskSpecFromMap(m map[string]interface{}) (*DiskSpec, error) {
	if m == nil {
		return &DiskSpec{}, nil
	}

	s := &DiskSpec{}
	// Parse baseImage
	if v, ok := m["baseImage"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.BaseImage = val
		} else {
			return nil, fmt.Errorf("field baseImage: expected string, got %T", v)
		}
	}
	// Parse size
	if v, ok := m["size"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Size = val
		} else {
			return nil, fmt.Errorf("field size: expected string, got %T", v)
		}
	}
	return s, nil
}

// ImageSpecFromMap creates a ImageSpec from a map[string]interface{}.
func ImageSpecFromMap(m map[string]interface{}) (*ImageSpec, error) {
	if m == nil {
		return &ImageSpec{}, nil
	}

	s := &ImageSpec{}
	// Parse alias
	if v, ok := m["alias"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Alias = val
		} else {
			return nil, fmt.Errorf("field alias: expected string, got %T", v)
		}
	}
	// Parse sha256
	if v, ok := m["sha256"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Sha256 = val
		} else {
			return nil, fmt.Errorf("field sha256: expected string, got %T", v)
		}
	}
	// Parse source
	if v, ok := m["source"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Source = val
		} else {
			return nil, fmt.Errorf("field source: expected string, got %T", v)
		}
	}
	return s, nil
}

// KeySpecFromMap creates a KeySpec from a map[string]interface{}.
func KeySpecFromMap(m map[string]interface{}) (*KeySpec, error) {
	if m == nil {
		return &KeySpec{}, nil
	}

	s := &KeySpec{}
	// Parse bits
	if v, ok := m["bits"]; ok && v != nil {
		switch val := v.(type) {
		case int:
			s.Bits = val
		case int64:
			s.Bits = int(val)
		case float64:
			s.Bits = int(val)
		default:
			return nil, fmt.Errorf("field bits: expected int, got %T", v)
		}
	}
	// Parse comment
	if v, ok := m["comment"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Comment = val
		} else {
			return nil, fmt.Errorf("field comment: expected string, got %T", v)
		}
	}
	// Parse outputDir
	if v, ok := m["outputDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.OutputDir = val
		} else {
			return nil, fmt.Errorf("field outputDir: expected string, got %T", v)
		}
	}
	// Parse type
	if v, ok := m["type"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Type = val
		} else {
			return nil, fmt.Errorf("field type: expected string, got %T", v)
		}
	}
	return s, nil
}

// TFTPSpecFromMap creates a TFTPSpec from a map[string]interface{}.
func TFTPSpecFromMap(m map[string]interface{}) (*TFTPSpec, error) {
	if m == nil {
		return &TFTPSpec{}, nil
	}

	s := &TFTPSpec{}
	// Parse bootFile
	if v, ok := m["bootFile"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.BootFile = val
		} else {
			return nil, fmt.Errorf("field bootFile: expected string, got %T", v)
		}
	}
	// Parse enabled
	if v, ok := m["enabled"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Enabled = val
		} else {
			return nil, fmt.Errorf("field enabled: expected bool, got %T", v)
		}
	}
	// Parse root
	if v, ok := m["root"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Root = val
		} else {
			return nil, fmt.Errorf("field root: expected string, got %T", v)
		}
	}
	return s, nil
}

// ProviderConfigFromMap creates a ProviderConfig from a map[string]interface{}.
func ProviderConfigFromMap(m map[string]interface{}) (*ProviderConfig, error) {
	if m == nil {
		return &ProviderConfig{}, nil
	}

	s := &ProviderConfig{}
	// Parse default
	if v, ok := m["default"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Default = val
		} else {
			return nil, fmt.Errorf("field default: expected bool, got %T", v)
		}
	}
	// Parse engine
	if v, ok := m["engine"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Engine = val
		} else {
			return nil, fmt.Errorf("field engine: expected string, got %T", v)
		}
	}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse spec
	if v, ok := m["spec"]; ok && v != nil {
		if mapVal, ok := v.(map[string]interface{}); ok {
			s.Spec = make(map[string]interface{}, len(mapVal))
			for key, val := range mapVal {
				s.Spec[key] = val.(interface{})
			}
		} else {
			return nil, fmt.Errorf("field spec: expected map, got %T", v)
		}
	}
	return s, nil
}

// SSHReadinessSpecFromMap creates a SSHReadinessSpec from a map[string]interface{}.
func SSHReadinessSpecFromMap(m map[string]interface{}) (*SSHReadinessSpec, error) {
	if m == nil {
		return &SSHReadinessSpec{}, nil
	}

	s := &SSHReadinessSpec{}
	// Parse enabled
	if v, ok := m["enabled"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Enabled = val
		} else {
			return nil, fmt.Errorf("field enabled: expected bool, got %T", v)
		}
	}
	// Parse privateKey
	if v, ok := m["privateKey"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.PrivateKey = val
		} else {
			return nil, fmt.Errorf("field privateKey: expected string, got %T", v)
		}
	}
	// Parse timeout
	if v, ok := m["timeout"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Timeout = val
		} else {
			return nil, fmt.Errorf("field timeout: expected string, got %T", v)
		}
	}
	// Parse user
	if v, ok := m["user"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.User = val
		} else {
			return nil, fmt.Errorf("field user: expected string, got %T", v)
		}
	}
	return s, nil
}

// ResourceRefFromMap creates a ResourceRef from a map[string]interface{}.
func ResourceRefFromMap(m map[string]interface{}) (*ResourceRef, error) {
	if m == nil {
		return &ResourceRef{}, nil
	}

	s := &ResourceRef{}
	// Parse kind
	if v, ok := m["kind"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Kind = val
		} else {
			return nil, fmt.Errorf("field kind: expected string, got %T", v)
		}
	}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse provider
	if v, ok := m["provider"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Provider = val
		} else {
			return nil, fmt.Errorf("field provider: expected string, got %T", v)
		}
	}
	return s, nil
}

// CloudInitEthernetConfigFromMap creates a CloudInitEthernetConfig from a map[string]interface{}.
func CloudInitEthernetConfigFromMap(m map[string]interface{}) (*CloudInitEthernetConfig, error) {
	if m == nil {
		return &CloudInitEthernetConfig{}, nil
	}

	s := &CloudInitEthernetConfig{}
	// Parse addresses
	if v, ok := m["addresses"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Addresses = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Addresses = append(s.Addresses, str)
				} else {
					return nil, fmt.Errorf("field addresses[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Addresses = arr
		} else {
			return nil, fmt.Errorf("field addresses: expected []string, got %T", v)
		}
	}
	// Parse dhcp4
	if v, ok := m["dhcp4"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.Dhcp4 = val
		} else {
			return nil, fmt.Errorf("field dhcp4: expected bool, got %T", v)
		}
	}
	// Parse gateway4
	if v, ok := m["gateway4"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Gateway4 = val
		} else {
			return nil, fmt.Errorf("field gateway4: expected string, got %T", v)
		}
	}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse nameservers
	if v, ok := m["nameservers"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := CloudInitNameserversFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field nameservers: %w", err)
			}
			if ref != nil {
				s.Nameservers = *ref
			}
		} else {
			return nil, fmt.Errorf("field nameservers: expected object, got %T", v)
		}
	}
	return s, nil
}

// ImageResourceFromMap creates a ImageResource from a map[string]interface{}.
func ImageResourceFromMap(m map[string]interface{}) (*ImageResource, error) {
	if m == nil {
		return &ImageResource{}, nil
	}

	s := &ImageResource{}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse spec
	if v, ok := m["spec"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := ImageSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field spec: %w", err)
			}
			if ref != nil {
				s.Spec = *ref
			}
		} else {
			return nil, fmt.Errorf("field spec: expected object, got %T", v)
		}
	}
	return s, nil
}

// KeyResourceFromMap creates a KeyResource from a map[string]interface{}.
func KeyResourceFromMap(m map[string]interface{}) (*KeyResource, error) {
	if m == nil {
		return &KeyResource{}, nil
	}

	s := &KeyResource{}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse provider
	if v, ok := m["provider"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Provider = val
		} else {
			return nil, fmt.Errorf("field provider: expected string, got %T", v)
		}
	}
	// Parse providerSpec
	if v, ok := m["providerSpec"]; ok && v != nil {
		if mapVal, ok := v.(map[string]interface{}); ok {
			s.ProviderSpec = make(map[string]interface{}, len(mapVal))
			for key, val := range mapVal {
				s.ProviderSpec[key] = val.(interface{})
			}
		} else {
			return nil, fmt.Errorf("field providerSpec: expected map, got %T", v)
		}
	}
	// Parse spec
	if v, ok := m["spec"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := KeySpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field spec: %w", err)
			}
			if ref != nil {
				s.Spec = *ref
			}
		} else {
			return nil, fmt.Errorf("field spec: expected object, got %T", v)
		}
	}
	return s, nil
}

// NetworkSpecFromMap creates a NetworkSpec from a map[string]interface{}.
func NetworkSpecFromMap(m map[string]interface{}) (*NetworkSpec, error) {
	if m == nil {
		return &NetworkSpec{}, nil
	}

	s := &NetworkSpec{}
	// Parse attachTo
	if v, ok := m["attachTo"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.AttachTo = val
		} else {
			return nil, fmt.Errorf("field attachTo: expected string, got %T", v)
		}
	}
	// Parse cidr
	if v, ok := m["cidr"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Cidr = val
		} else {
			return nil, fmt.Errorf("field cidr: expected string, got %T", v)
		}
	}
	// Parse dhcp
	if v, ok := m["dhcp"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := DHCPSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field dhcp: %w", err)
			}
			if ref != nil {
				s.Dhcp = *ref
			}
		} else {
			return nil, fmt.Errorf("field dhcp: expected object, got %T", v)
		}
	}
	// Parse dns
	if v, ok := m["dns"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := DNSSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field dns: %w", err)
			}
			if ref != nil {
				s.Dns = *ref
			}
		} else {
			return nil, fmt.Errorf("field dns: expected object, got %T", v)
		}
	}
	// Parse gateway
	if v, ok := m["gateway"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Gateway = val
		} else {
			return nil, fmt.Errorf("field gateway: expected string, got %T", v)
		}
	}
	// Parse mtu
	if v, ok := m["mtu"]; ok && v != nil {
		switch val := v.(type) {
		case int:
			s.Mtu = val
		case int64:
			s.Mtu = int(val)
		case float64:
			s.Mtu = int(val)
		default:
			return nil, fmt.Errorf("field mtu: expected int, got %T", v)
		}
	}
	// Parse tftp
	if v, ok := m["tftp"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := TFTPSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field tftp: %w", err)
			}
			if ref != nil {
				s.Tftp = *ref
			}
		} else {
			return nil, fmt.Errorf("field tftp: expected object, got %T", v)
		}
	}
	return s, nil
}

// ReadinessSpecFromMap creates a ReadinessSpec from a map[string]interface{}.
func ReadinessSpecFromMap(m map[string]interface{}) (*ReadinessSpec, error) {
	if m == nil {
		return &ReadinessSpec{}, nil
	}

	s := &ReadinessSpec{}
	// Parse ssh
	if v, ok := m["ssh"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := SSHReadinessSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field ssh: %w", err)
			}
			if ref != nil {
				s.Ssh = *ref
			}
		} else {
			return nil, fmt.Errorf("field ssh: expected object, got %T", v)
		}
	}
	return s, nil
}

// CloudInitNetworkConfigFromMap creates a CloudInitNetworkConfig from a map[string]interface{}.
func CloudInitNetworkConfigFromMap(m map[string]interface{}) (*CloudInitNetworkConfig, error) {
	if m == nil {
		return &CloudInitNetworkConfig{}, nil
	}

	s := &CloudInitNetworkConfig{}
	// Parse ethernets
	if v, ok := m["ethernets"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Ethernets = make([]CloudInitEthernetConfig, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := CloudInitEthernetConfigFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field ethernets[%d]: %w", i, err)
					}
					if ref != nil {
						s.Ethernets = append(s.Ethernets, *ref)
					}
				} else {
					return nil, fmt.Errorf("field ethernets[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field ethernets: expected []object, got %T", v)
		}
	}
	return s, nil
}

// NetworkResourceFromMap creates a NetworkResource from a map[string]interface{}.
func NetworkResourceFromMap(m map[string]interface{}) (*NetworkResource, error) {
	if m == nil {
		return &NetworkResource{}, nil
	}

	s := &NetworkResource{}
	// Parse kind
	if v, ok := m["kind"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Kind = val
		} else {
			return nil, fmt.Errorf("field kind: expected string, got %T", v)
		}
	}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse provider
	if v, ok := m["provider"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Provider = val
		} else {
			return nil, fmt.Errorf("field provider: expected string, got %T", v)
		}
	}
	// Parse providerSpec
	if v, ok := m["providerSpec"]; ok && v != nil {
		if mapVal, ok := v.(map[string]interface{}); ok {
			s.ProviderSpec = make(map[string]interface{}, len(mapVal))
			for key, val := range mapVal {
				s.ProviderSpec[key] = val.(interface{})
			}
		} else {
			return nil, fmt.Errorf("field providerSpec: expected map, got %T", v)
		}
	}
	// Parse spec
	if v, ok := m["spec"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := NetworkSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field spec: %w", err)
			}
			if ref != nil {
				s.Spec = *ref
			}
		} else {
			return nil, fmt.Errorf("field spec: expected object, got %T", v)
		}
	}
	return s, nil
}

// CloudInitSpecFromMap creates a CloudInitSpec from a map[string]interface{}.
func CloudInitSpecFromMap(m map[string]interface{}) (*CloudInitSpec, error) {
	if m == nil {
		return &CloudInitSpec{}, nil
	}

	s := &CloudInitSpec{}
	// Parse hostname
	if v, ok := m["hostname"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Hostname = val
		} else {
			return nil, fmt.Errorf("field hostname: expected string, got %T", v)
		}
	}
	// Parse networkConfig
	if v, ok := m["networkConfig"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := CloudInitNetworkConfigFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field networkConfig: %w", err)
			}
			if ref != nil {
				s.NetworkConfig = *ref
			}
		} else {
			return nil, fmt.Errorf("field networkConfig: expected object, got %T", v)
		}
	}
	// Parse packages
	if v, ok := m["packages"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Packages = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Packages = append(s.Packages, str)
				} else {
					return nil, fmt.Errorf("field packages[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Packages = arr
		} else {
			return nil, fmt.Errorf("field packages: expected []string, got %T", v)
		}
	}
	// Parse runcmd
	if v, ok := m["runcmd"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Runcmd = make([]string, 0, len(arr))
			for i, item := range arr {
				if str, ok := item.(string); ok {
					s.Runcmd = append(s.Runcmd, str)
				} else {
					return nil, fmt.Errorf("field runcmd[%d]: expected string, got %T", i, item)
				}
			}
		} else if arr, ok := v.([]string); ok {
			s.Runcmd = arr
		} else {
			return nil, fmt.Errorf("field runcmd: expected []string, got %T", v)
		}
	}
	// Parse users
	if v, ok := m["users"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Users = make([]UserSpec, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := UserSpecFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field users[%d]: %w", i, err)
					}
					if ref != nil {
						s.Users = append(s.Users, *ref)
					}
				} else {
					return nil, fmt.Errorf("field users[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field users: expected []object, got %T", v)
		}
	}
	// Parse writeFiles
	if v, ok := m["writeFiles"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.WriteFiles = make([]WriteFileSpec, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := WriteFileSpecFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field writeFiles[%d]: %w", i, err)
					}
					if ref != nil {
						s.WriteFiles = append(s.WriteFiles, *ref)
					}
				} else {
					return nil, fmt.Errorf("field writeFiles[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field writeFiles: expected []object, got %T", v)
		}
	}
	return s, nil
}

// VMSpecFromMap creates a VMSpec from a map[string]interface{}.
func VMSpecFromMap(m map[string]interface{}) (*VMSpec, error) {
	if m == nil {
		return &VMSpec{}, nil
	}

	s := &VMSpec{}
	// Parse boot
	if v, ok := m["boot"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := BootSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field boot: %w", err)
			}
			if ref != nil {
				s.Boot = *ref
			}
		} else {
			return nil, fmt.Errorf("field boot: expected object, got %T", v)
		}
	}
	// Parse cloudInit
	if v, ok := m["cloudInit"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := CloudInitSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field cloudInit: %w", err)
			}
			if ref != nil {
				s.CloudInit = *ref
			}
		} else {
			return nil, fmt.Errorf("field cloudInit: expected object, got %T", v)
		}
	}
	// Parse disk
	if v, ok := m["disk"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := DiskSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field disk: %w", err)
			}
			if ref != nil {
				s.Disk = *ref
			}
		} else {
			return nil, fmt.Errorf("field disk: expected object, got %T", v)
		}
	}
	// Parse memory
	if v, ok := m["memory"]; ok && v != nil {
		switch val := v.(type) {
		case int:
			s.Memory = val
		case int64:
			s.Memory = int(val)
		case float64:
			s.Memory = int(val)
		default:
			return nil, fmt.Errorf("field memory: expected int, got %T", v)
		}
	}
	// Parse network
	if v, ok := m["network"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Network = val
		} else {
			return nil, fmt.Errorf("field network: expected string, got %T", v)
		}
	}
	// Parse readiness
	if v, ok := m["readiness"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := ReadinessSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field readiness: %w", err)
			}
			if ref != nil {
				s.Readiness = *ref
			}
		} else {
			return nil, fmt.Errorf("field readiness: expected object, got %T", v)
		}
	}
	// Parse vcpus
	if v, ok := m["vcpus"]; ok && v != nil {
		switch val := v.(type) {
		case int:
			s.Vcpus = val
		case int64:
			s.Vcpus = int(val)
		case float64:
			s.Vcpus = int(val)
		default:
			return nil, fmt.Errorf("field vcpus: expected int, got %T", v)
		}
	}
	return s, nil
}

// VMResourceFromMap creates a VMResource from a map[string]interface{}.
func VMResourceFromMap(m map[string]interface{}) (*VMResource, error) {
	if m == nil {
		return &VMResource{}, nil
	}

	s := &VMResource{}
	// Parse name
	if v, ok := m["name"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Name = val
		} else {
			return nil, fmt.Errorf("field name: expected string, got %T", v)
		}
	}
	// Parse provider
	if v, ok := m["provider"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.Provider = val
		} else {
			return nil, fmt.Errorf("field provider: expected string, got %T", v)
		}
	}
	// Parse providerSpec
	if v, ok := m["providerSpec"]; ok && v != nil {
		if mapVal, ok := v.(map[string]interface{}); ok {
			s.ProviderSpec = make(map[string]interface{}, len(mapVal))
			for key, val := range mapVal {
				s.ProviderSpec[key] = val.(interface{})
			}
		} else {
			return nil, fmt.Errorf("field providerSpec: expected map, got %T", v)
		}
	}
	// Parse spec
	if v, ok := m["spec"]; ok && v != nil {
		if obj, ok := v.(map[string]interface{}); ok {
			ref, err := VMSpecFromMap(obj)
			if err != nil {
				return nil, fmt.Errorf("field spec: %w", err)
			}
			if ref != nil {
				s.Spec = *ref
			}
		} else {
			return nil, fmt.Errorf("field spec: expected object, got %T", v)
		}
	}
	return s, nil
}

// SpecFromMap creates a Spec from a map[string]interface{}.
func SpecFromMap(m map[string]interface{}) (*Spec, error) {
	if m == nil {
		return &Spec{}, nil
	}

	s := &Spec{}
	// Parse artifactDir
	if v, ok := m["artifactDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.ArtifactDir = val
		} else {
			return nil, fmt.Errorf("field artifactDir: expected string, got %T", v)
		}
	}
	// Parse cleanupOnFailure
	if v, ok := m["cleanupOnFailure"]; ok && v != nil {
		if val, ok := v.(bool); ok {
			s.CleanupOnFailure = val
		} else {
			return nil, fmt.Errorf("field cleanupOnFailure: expected bool, got %T", v)
		}
	}
	// Parse defaultBaseImage
	if v, ok := m["defaultBaseImage"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.DefaultBaseImage = val
		} else {
			return nil, fmt.Errorf("field defaultBaseImage: expected string, got %T", v)
		}
	}
	// Parse defaultProvider
	if v, ok := m["defaultProvider"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.DefaultProvider = val
		} else {
			return nil, fmt.Errorf("field defaultProvider: expected string, got %T", v)
		}
	}
	// Parse imageCacheDir
	if v, ok := m["imageCacheDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.ImageCacheDir = val
		} else {
			return nil, fmt.Errorf("field imageCacheDir: expected string, got %T", v)
		}
	}
	// Parse images
	if v, ok := m["images"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Images = make([]ImageResource, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := ImageResourceFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field images[%d]: %w", i, err)
					}
					if ref != nil {
						s.Images = append(s.Images, *ref)
					}
				} else {
					return nil, fmt.Errorf("field images[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field images: expected []object, got %T", v)
		}
	}
	// Parse keys
	if v, ok := m["keys"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Keys = make([]KeyResource, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := KeyResourceFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field keys[%d]: %w", i, err)
					}
					if ref != nil {
						s.Keys = append(s.Keys, *ref)
					}
				} else {
					return nil, fmt.Errorf("field keys[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field keys: expected []object, got %T", v)
		}
	}
	// Parse networks
	if v, ok := m["networks"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Networks = make([]NetworkResource, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := NetworkResourceFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field networks[%d]: %w", i, err)
					}
					if ref != nil {
						s.Networks = append(s.Networks, *ref)
					}
				} else {
					return nil, fmt.Errorf("field networks[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field networks: expected []object, got %T", v)
		}
	}
	// Parse providers
	if v, ok := m["providers"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Providers = make([]ProviderConfig, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := ProviderConfigFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field providers[%d]: %w", i, err)
					}
					if ref != nil {
						s.Providers = append(s.Providers, *ref)
					}
				} else {
					return nil, fmt.Errorf("field providers[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field providers: expected []object, got %T", v)
		}
	}
	// Parse stateDir
	if v, ok := m["stateDir"]; ok && v != nil {
		if val, ok := v.(string); ok {
			s.StateDir = val
		} else {
			return nil, fmt.Errorf("field stateDir: expected string, got %T", v)
		}
	}
	// Parse vms
	if v, ok := m["vms"]; ok && v != nil {
		if arr, ok := v.([]interface{}); ok {
			s.Vms = make([]VMResource, 0, len(arr))
			for i, item := range arr {
				if obj, ok := item.(map[string]interface{}); ok {
					ref, err := VMResourceFromMap(obj)
					if err != nil {
						return nil, fmt.Errorf("field vms[%d]: %w", i, err)
					}
					if ref != nil {
						s.Vms = append(s.Vms, *ref)
					}
				} else {
					return nil, fmt.Errorf("field vms[%d]: expected object, got %T", i, item)
				}
			}
		} else {
			return nil, fmt.Errorf("field vms: expected []object, got %T", v)
		}
	}
	return s, nil
}

// ToMap converts a BootSpec to a map[string]interface{}.
func (s *BootSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Firmware != "" {
		m["firmware"] = s.Firmware
	}
	if len(s.Order) > 0 {
		m["order"] = s.Order
	}
	return m
}

// ToMap converts a CloudInitNameservers to a map[string]interface{}.
func (s *CloudInitNameservers) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if len(s.Addresses) > 0 {
		m["addresses"] = s.Addresses
	}
	return m
}

// ToMap converts a UserSpec to a map[string]interface{}.
func (s *UserSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.SshAuthorizedKeys) > 0 {
		m["sshAuthorizedKeys"] = s.SshAuthorizedKeys
	}
	if s.Sudo != "" {
		m["sudo"] = s.Sudo
	}
	return m
}

// ToMap converts a WriteFileSpec to a map[string]interface{}.
func (s *WriteFileSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Content != "" {
		m["content"] = s.Content
	}
	if s.Path != "" {
		m["path"] = s.Path
	}
	if s.Permissions != "" {
		m["permissions"] = s.Permissions
	}
	return m
}

// ToMap converts a DHCPSpec to a map[string]interface{}.
func (s *DHCPSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.LeaseTime != "" {
		m["leaseTime"] = s.LeaseTime
	}
	if s.RangeEnd != "" {
		m["rangeEnd"] = s.RangeEnd
	}
	if s.RangeStart != "" {
		m["rangeStart"] = s.RangeStart
	}
	return m
}

// ToMap converts a DNSSpec to a map[string]interface{}.
func (s *DNSSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if len(s.Servers) > 0 {
		m["servers"] = s.Servers
	}
	return m
}

// ToMap converts a DiskSpec to a map[string]interface{}.
func (s *DiskSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.BaseImage != "" {
		m["baseImage"] = s.BaseImage
	}
	if s.Size != "" {
		m["size"] = s.Size
	}
	return m
}

// ToMap converts a ImageSpec to a map[string]interface{}.
func (s *ImageSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Alias != "" {
		m["alias"] = s.Alias
	}
	if s.Sha256 != "" {
		m["sha256"] = s.Sha256
	}
	if s.Source != "" {
		m["source"] = s.Source
	}
	return m
}

// ToMap converts a KeySpec to a map[string]interface{}.
func (s *KeySpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Bits != 0 {
		m["bits"] = s.Bits
	}
	if s.Comment != "" {
		m["comment"] = s.Comment
	}
	if s.OutputDir != "" {
		m["outputDir"] = s.OutputDir
	}
	if s.Type != "" {
		m["type"] = s.Type
	}
	return m
}

// ToMap converts a TFTPSpec to a map[string]interface{}.
func (s *TFTPSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.BootFile != "" {
		m["bootFile"] = s.BootFile
	}
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.Root != "" {
		m["root"] = s.Root
	}
	return m
}

// ToMap converts a ProviderConfig to a map[string]interface{}.
func (s *ProviderConfig) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Default {
		m["default"] = s.Default
	}
	if s.Engine != "" {
		m["engine"] = s.Engine
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if len(s.Spec) > 0 {
		m["spec"] = s.Spec
	}
	return m
}

// ToMap converts a SSHReadinessSpec to a map[string]interface{}.
func (s *SSHReadinessSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Enabled {
		m["enabled"] = s.Enabled
	}
	if s.PrivateKey != "" {
		m["privateKey"] = s.PrivateKey
	}
	if s.Timeout != "" {
		m["timeout"] = s.Timeout
	}
	if s.User != "" {
		m["user"] = s.User
	}
	return m
}

// ToMap converts a ResourceRef to a map[string]interface{}.
func (s *ResourceRef) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Kind != "" {
		m["kind"] = s.Kind
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Provider != "" {
		m["provider"] = s.Provider
	}
	return m
}

// ToMap converts a CloudInitEthernetConfig to a map[string]interface{}.
func (s *CloudInitEthernetConfig) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if len(s.Addresses) > 0 {
		m["addresses"] = s.Addresses
	}
	if s.Dhcp4 {
		m["dhcp4"] = s.Dhcp4
	}
	if s.Gateway4 != "" {
		m["gateway4"] = s.Gateway4
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	// Reference type CloudInitNameservers
	refMap := s.Nameservers.ToMap()
	if len(refMap) > 0 {
		m["nameservers"] = refMap
	}
	return m
}

// ToMap converts a ImageResource to a map[string]interface{}.
func (s *ImageResource) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Name != "" {
		m["name"] = s.Name
	}
	// Reference type ImageSpec
	refMap := s.Spec.ToMap()
	if len(refMap) > 0 {
		m["spec"] = refMap
	}
	return m
}

// ToMap converts a KeyResource to a map[string]interface{}.
func (s *KeyResource) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Provider != "" {
		m["provider"] = s.Provider
	}
	if len(s.ProviderSpec) > 0 {
		m["providerSpec"] = s.ProviderSpec
	}
	// Reference type KeySpec
	refMap := s.Spec.ToMap()
	if len(refMap) > 0 {
		m["spec"] = refMap
	}
	return m
}

// ToMap converts a NetworkSpec to a map[string]interface{}.
func (s *NetworkSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.AttachTo != "" {
		m["attachTo"] = s.AttachTo
	}
	if s.Cidr != "" {
		m["cidr"] = s.Cidr
	}
	// Reference type DHCPSpec
	refMap := s.Dhcp.ToMap()
	if len(refMap) > 0 {
		m["dhcp"] = refMap
	}
	// Reference type DNSSpec
	refMap = s.Dns.ToMap()
	if len(refMap) > 0 {
		m["dns"] = refMap
	}
	if s.Gateway != "" {
		m["gateway"] = s.Gateway
	}
	if s.Mtu != 0 {
		m["mtu"] = s.Mtu
	}
	// Reference type TFTPSpec
	refMap = s.Tftp.ToMap()
	if len(refMap) > 0 {
		m["tftp"] = refMap
	}
	return m
}

// ToMap converts a ReadinessSpec to a map[string]interface{}.
func (s *ReadinessSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	// Reference type SSHReadinessSpec
	refMap := s.Ssh.ToMap()
	if len(refMap) > 0 {
		m["ssh"] = refMap
	}
	return m
}

// ToMap converts a CloudInitNetworkConfig to a map[string]interface{}.
func (s *CloudInitNetworkConfig) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if len(s.Ethernets) > 0 {
		arr := make([]interface{}, 0, len(s.Ethernets))
		for _, item := range s.Ethernets {
			arr = append(arr, item.ToMap())
		}
		m["ethernets"] = arr
	}
	return m
}

// ToMap converts a NetworkResource to a map[string]interface{}.
func (s *NetworkResource) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Kind != "" {
		m["kind"] = s.Kind
	}
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Provider != "" {
		m["provider"] = s.Provider
	}
	if len(s.ProviderSpec) > 0 {
		m["providerSpec"] = s.ProviderSpec
	}
	// Reference type NetworkSpec
	refMap := s.Spec.ToMap()
	if len(refMap) > 0 {
		m["spec"] = refMap
	}
	return m
}

// ToMap converts a CloudInitSpec to a map[string]interface{}.
func (s *CloudInitSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Hostname != "" {
		m["hostname"] = s.Hostname
	}
	// Reference type CloudInitNetworkConfig
	refMap := s.NetworkConfig.ToMap()
	if len(refMap) > 0 {
		m["networkConfig"] = refMap
	}
	if len(s.Packages) > 0 {
		m["packages"] = s.Packages
	}
	if len(s.Runcmd) > 0 {
		m["runcmd"] = s.Runcmd
	}
	if len(s.Users) > 0 {
		arr := make([]interface{}, 0, len(s.Users))
		for _, item := range s.Users {
			arr = append(arr, item.ToMap())
		}
		m["users"] = arr
	}
	if len(s.WriteFiles) > 0 {
		arr := make([]interface{}, 0, len(s.WriteFiles))
		for _, item := range s.WriteFiles {
			arr = append(arr, item.ToMap())
		}
		m["writeFiles"] = arr
	}
	return m
}

// ToMap converts a VMSpec to a map[string]interface{}.
func (s *VMSpec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	// Reference type BootSpec
	refMap := s.Boot.ToMap()
	if len(refMap) > 0 {
		m["boot"] = refMap
	}
	// Reference type CloudInitSpec
	refMap = s.CloudInit.ToMap()
	if len(refMap) > 0 {
		m["cloudInit"] = refMap
	}
	// Reference type DiskSpec
	refMap = s.Disk.ToMap()
	if len(refMap) > 0 {
		m["disk"] = refMap
	}
	if s.Memory != 0 {
		m["memory"] = s.Memory
	}
	if s.Network != "" {
		m["network"] = s.Network
	}
	// Reference type ReadinessSpec
	refMap = s.Readiness.ToMap()
	if len(refMap) > 0 {
		m["readiness"] = refMap
	}
	if s.Vcpus != 0 {
		m["vcpus"] = s.Vcpus
	}
	return m
}

// ToMap converts a VMResource to a map[string]interface{}.
func (s *VMResource) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.Name != "" {
		m["name"] = s.Name
	}
	if s.Provider != "" {
		m["provider"] = s.Provider
	}
	if len(s.ProviderSpec) > 0 {
		m["providerSpec"] = s.ProviderSpec
	}
	// Reference type VMSpec
	refMap := s.Spec.ToMap()
	if len(refMap) > 0 {
		m["spec"] = refMap
	}
	return m
}

// ToMap converts a Spec to a map[string]interface{}.
func (s *Spec) ToMap() map[string]interface{} {
	if s == nil {
		return nil
	}

	m := make(map[string]interface{})
	if s.ArtifactDir != "" {
		m["artifactDir"] = s.ArtifactDir
	}
	if s.CleanupOnFailure {
		m["cleanupOnFailure"] = s.CleanupOnFailure
	}
	if s.DefaultBaseImage != "" {
		m["defaultBaseImage"] = s.DefaultBaseImage
	}
	if s.DefaultProvider != "" {
		m["defaultProvider"] = s.DefaultProvider
	}
	if s.ImageCacheDir != "" {
		m["imageCacheDir"] = s.ImageCacheDir
	}
	if len(s.Images) > 0 {
		arr := make([]interface{}, 0, len(s.Images))
		for _, item := range s.Images {
			arr = append(arr, item.ToMap())
		}
		m["images"] = arr
	}
	if len(s.Keys) > 0 {
		arr := make([]interface{}, 0, len(s.Keys))
		for _, item := range s.Keys {
			arr = append(arr, item.ToMap())
		}
		m["keys"] = arr
	}
	if len(s.Networks) > 0 {
		arr := make([]interface{}, 0, len(s.Networks))
		for _, item := range s.Networks {
			arr = append(arr, item.ToMap())
		}
		m["networks"] = arr
	}
	if len(s.Providers) > 0 {
		arr := make([]interface{}, 0, len(s.Providers))
		for _, item := range s.Providers {
			arr = append(arr, item.ToMap())
		}
		m["providers"] = arr
	}
	if s.StateDir != "" {
		m["stateDir"] = s.StateDir
	}
	if len(s.Vms) > 0 {
		arr := make([]interface{}, 0, len(s.Vms))
		for _, item := range s.Vms {
			arr = append(arr, item.ToMap())
		}
		m["vms"] = arr
	}
	return m
}

// FromMap creates a Spec from a map[string]interface{}.
// This is the main entry point for parsing the spec field from forge.yaml.
func FromMap(m map[string]interface{}) (*Spec, error) {
	return SpecFromMap(m)
}
